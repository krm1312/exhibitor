package com.netflix.exhibitor.core.config.cassandrahz;

import com.datastax.driver.core.*;
import com.netflix.exhibitor.core.config.*;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.Date;
import java.util.Properties;

/**
 * Created by kevinm on 3/6/15.
 */
public class CassandraConfigProvider implements ConfigProvider {

    private String clusterName;
    private Cluster cassandraCluster;
    private Session cassandraSession;
    private Properties defaultProperties;
    private HazelcastPseudoLock lock;

    private PreparedStatement cqlQuery;
    private PreparedStatement cqlInsert;

    public CassandraConfigProvider(Properties defaultProperties, String clusterName, String cassandraHosts,
                                   int cassandraPort, String cassandraKeyspace) {
        this.defaultProperties = defaultProperties;
        this.clusterName = clusterName;
        this.cassandraCluster = Cluster.builder()
                .withPort(cassandraPort)
                .addContactPoints(cassandraHosts.split(","))
                .withQueryOptions(new QueryOptions().setConsistencyLevel(ConsistencyLevel.LOCAL_QUORUM))
                .build();

        cassandraSession = cassandraCluster.connect();
        // For more complicated keyspace options, create it manually first
        cassandraSession.execute("create keyspace if not exists " + cassandraKeyspace +
                " with replication = { 'class' : 'SimpleStrategy', 'replication_factor' : 1 }");

        cassandraSession.execute("create table if not exists " + cassandraKeyspace + ".config " +
                "(cluster_name varchar primary key, " +
                " properties text, " +
                " last_modified timestamp)");

        this.cqlQuery = cassandraSession.prepare("select properties, last_modified from " + cassandraKeyspace + ".config where cluster_name = ?");
        this.cqlInsert = cassandraSession.prepare("insert into " + cassandraKeyspace + ".config (cluster_name, properties, last_modified) values (?, ?, ?)");

        this.lock = new HazelcastPseudoLock(clusterName);
    }

    private Row getConfigFromCassandra() {
        ResultSet result = cassandraSession.execute(cqlQuery.bind(clusterName));
        if (!result.isExhausted()) {
            return result.one();
        }
        return null;
    }

    @Override
    public LoadedInstanceConfig loadConfig() throws Exception {

        Properties properties = new Properties();
        Date lastModified = new Date();

        Row row = getConfigFromCassandra();
        if (null != row) {
            lastModified = row.getDate("last_modified");
            properties.load(new StringReader(row.getString("properties")));
        }

        PropertyBasedInstanceConfig config = new PropertyBasedInstanceConfig(properties, defaultProperties);
        return new LoadedInstanceConfig(config, lastModified.getTime());

    }

    @Override
    public LoadedInstanceConfig storeConfig(ConfigCollection config, long compareVersion) throws Exception {

        Row row = getConfigFromCassandra();
        if (null != row && row.getDate("last_modified").getTime() != compareVersion) {
            return null;
        }

        Date now = new Date();

        PropertyBasedInstanceConfig propertyBasedInstanceConfig = new PropertyBasedInstanceConfig(config);

        StringWriter sw = new StringWriter();
        propertyBasedInstanceConfig.getProperties().store(sw, "Auto-generated by Exhibitor");

        cassandraSession.execute(cqlInsert.bind(clusterName, sw.toString(), now));

        return new LoadedInstanceConfig(propertyBasedInstanceConfig, now.getTime());

    }

    @Override
    public PseudoLock newPseudoLock() throws Exception {
        return lock;
    }

    @Override
    public void close() throws IOException {
    }

    @Override
    public void start() throws Exception {
    }

}
